#summary System#'s key concepts
#labels Phase-Design

= Introduction =

System# is a _system-level design language_ (SLDL). It's intent is to support the description of real-time embedded systems at different levels of abstraction. Precisely, System# is not a language on its own. Neither is it a new programming language, nor does it modify the syntax of any existing language. From a technological point of view, it's just a .NET library which provides the building blocks needed to construct, simulate and translate system models.

So why do we call it a language then? That's because System# comes with a bunch of design rules and coding guidelines. You're _not_ completely free in how you code your design. Just that your code is compilable and even runs without throwing an exception does not mean it's a valid System# design. If you want to create re-usable designs and if you want the System# framework to analyze and translate your design, you'd better adhere to the rules. That's why we call System# a _domain-specific embedded language_ (DSEL). Theoretically, you can use any .NET-enabled language to implement your design. However, we recommend C# as it provides just the right syntactic sugar needed you describe System# designs efficiently.

= Why yet-another-SLDL? =

You're probably familiar with other SLDLs, such as SystemVerilog and SystemC. These widespread and matured languages assemble are large community, are supported by many EDA tools and proved their practicability in countless academic and industrial applications. So why System#? To come to the point:
  * .NET is a powerful framework whose capabilities go far beyond the built-in features of C/C++ and its standard libraries. Why not make them available to system and hardware developers?
  * Did you ever try to develop some automated code analysis for SystemC? Be it `SomeInterfaceSynthesis`, `MyCoolNewDocumentationGenerator` or `MyOwnHighlevelSynthesisAlgorithm`, you'll soon find that things get ugly. You need to setup a C++ parser and make it understand the SystemC-specific parts. Strictly speaking, a SystemC model does not exist until it is _elaborated_. So you need to execute the elaboration part of the SystemC design, inspect its program space and combine this information with the abstract syntax tree generated by your parser. Intricate! That's why SystemC synthesis is supported by only few commercially-available wickedly expensive tools. The .NET framework, however, simplifies things a lot: It provides a powerful reflection API and requires application binaries to be encoded in a standardized platform-independent intermediate representation: the Common Intermediate Language (CIL). CIL was indeed designed for manageable program analysis: Any CIL just-in-time compiler applies inference techniques in order to deliver optimal target code. With the help of reflection and CIL analysis, System# is able to provide a clean reflection interface for system-level designs. This interface is used for model-to-model transformations and implementation code synthesis. A major goal of System# is to provide researchers an open and flexible integration platform to prototype behavioral synthesis algorithms, model-to-model transformations, code generators and applications we don't even think of.

= System# modeling =

If you're familiar with SystemC and/or VHDL, you'll find that things are very similar in System#. The following table will give you a brief overview:

|| *VHDL concept* || *SystemC concept* || *System# concept* ||
|| `entity`/`architecture` || derive from `sc_module` || derive from `Component` ||
|| `component` || `sc_module` instance || `Component` instance ||
|| `port` || `sc_port<type>` || C# property of `type` ||
|| `signal` || `sc_signal<type>` || `Signal<type>` ||
|| `process` without `wait` statements || call to `sc_process()` || call to `AddProcess()` ||
|| `process` with `wait` statements || call to `sc_thread()` || call to `AddThread()` ||
|| n.a. || clocked thread || call to `AddClockedThread()` ||

The next subsections will dive into the details. All code examples are given in C#.

== Components and hierarchical composition ==

A System# design is hierachically composed of _components_. A component encapsulates the behavior of a certain design part and can itself contain further components. To declare a component type, derive a class from `SystemSharp.Components`:
<code language="cs">
import SystemSharp.Components;

class MyComponent: Component
{
}
</code>
If your component class shall contain a child component, just declare it as a field and instantiate them inside the constructor:
<code language="cs">
class MyTopComponent: Component
{
    private MyComponent child;

    public MyTopComponent()
    {
        child = new MyComponent();
    }
}
</code>

== Component interfaces: Ports ==

The only way for a component to interact with its environment is through _ports_. A port can be thought as of an interface which exposes a certain functionality to the component. In hardware design, a port models a discrete signal input or output. In System#, ports are described by C# properties. System# ports are _always_ assigned from outside the component (a process called _binding_) and read from _inside_. Therefore, a port property has a `public` `set`-accessor and a `private` `get`-accessor (yes, the accessor modifications are converse compared to usual programming practice).
  * Signal input ports are declared through a property of type `In<Type>` where `Type` is the signal value data type.
  * Signal output ports are declared through a property of type `Out<Type>` where `Type` is the signal value data type.
  * Bidirectional signal ports are declared through a property of type `InOut<Type>` where `Type` is the signal value data type.
Let's declare a component having a `bool`-valued input, an `StdLogic`-valued input, an `int`-valued output and an `StdLogicVector`-valued output:
<code language="cs">
class MyComponent: Component
{
  public In<bool> In1 { get; private set; }
  public In<StdLogic> In2 { get; private set; }
  public Out<int> Out1 { get; private set; }
  public Out<StdLogicVector> Out2 { get; private set; }
}
</code>
Now assume that some other component, `MyTopComponent`, instantiates `MyComponent` as child component. Then `MyTopComponent` is responsible for associating each port of `MyComponent` with an appropriate signal instance (signals are discussed later). This process is called binding and is attended best by using the `Bind()` method which expects a delegate which describes the bind operations to be carried out:
<code language="cs">
class MyTopComponent: Component
{
    private MySubComponent child;

     private Signal<bool> sig1 = new Signal<bool>();
    private SLSignal sig2 = new SLSignal();
    private Signal<int> sig3 = new Signal<int>();
    private SLVSignal sig4 = new SLVSignal();

     public MyTopComponent()
    {
        child = new MySubComponent();
        Bind(() => {
          child.In1 = sig1;
          child.In2 = sig2;
          child.Out1 = sig3;
          child.Out2 = sig4;
        });
    }
}
</code>

== Channels and signals ==

Ports constitute a component's interface. We still need a thing which stores the actual information which is exchanged by ports, a thing where we can bind those ports to. This thing is called a _channel_. Whereas a component encapsulates the _computation_ which takes place inside a system part, a channel models _communication_. In hardware design, the most popular realization of a channel is a signal.

`Channel` (namespace: `SystemSharp.Components`) is System#'s abstract base class used for all channel realizations. Signals are implemented by class `Signal<Type>`. `Type` is a generic type parameter and depicts the data type of the carried signal value. System# offers special signal implementations for resolved data types.
  * Class `SLSignal` is a signal of data type `StdLogic`.
  * Class `SLVSignal` is a signal of data type `StdLogicVector`. `SLVSignal` needs one constructor argument which tells the desired width of the stored logic vector.
  * Use `Signal<Type>` for any other data type.

Data access to signals is governed by a set of properties:
|| *Property name* || *Access restrictions* || *Description* ||
|| `InitialValue` || read/write. Only before simulation. || Sets/gets the signal's value at simulation time 0. ||
|| `Cur` || read-only. Only during simulation. || Gets the signal's value. ||
|| `Next` || write-only. Only during simulation. || Sets the signal's value. ||
|| `Pre` || read-only. Only during simulation. || Gets the value the signal had prior to the current event. ||

The preset of `InitialValue` for...
  * an `SLSignal` instance is `'U'`,
  * an `SLVSignal` instance is `'UUU...U'`,
  * a `Signal<Type>` is `default(Type)`.

== Processes ==

A process is the place where actual design action occurs. Technologically, a process is a method without any arguments. However, it has a special meaning in that a process acts like a program's `main` function. As we're modeling a concurrent system, there are multiple `main` functions in parallel.

System# distinguishes three kind of processes:
  * A *triggered process* executes its implementing method due to some event. The set of events which are capable of triggering the process is specified inside the process _sensitivity list_. A triggered process consumes no (simulation) time during its execution. Thus, it may not call any of the `DesignContext.Wait(...)` methods.
  * A *threaded process* starts executing its implementing method from the very beginning. It incorporates the `DesignContext.Wait(...)` methods to pause its execution until some event occurs.
  * A *clocked thread* is a special threaded process and especially useful to model synthesizable synchronous finite state machines. The clocked thread pre-defines its sensitivity the rising or falling edge event of a clock signal. It is only allowed to call `DesignContext.Wait()` (without any arguments) which will pause its execution for one clock cycle.
To turn a method into a process, the method must be registered by a special framework call. The registration must take place inside the overwritten `Initialize` method of a component. Which framework call to use depends on the process kind. Assume the method to be registered has the identifier `MyMethod`:
|| *Task* || *Syntax* || *Remarks* ||
|| Register a *triggered process* || `AddProcess(MyMethod, ...)` || The sensitivity list is specified by the following arguments ||
|| Register a *threaded process* || `AddThread(MyMethod)` || ||
|| Register a *clocked thread* || `AddClockedThread(MyMethod, Clk.RisingEdge, Clk)` or<br> `AddClockedThread(MyMethod, Clk.FallingEdge, Clk)` || `Clk` depicts the desired clock signal. It must be of type `StdLogic` or `bool`. ||

=== Example: Counter with triggered process ===

The following example describes a synchronous binary n-bit counter. The increment process is realized using a triggered process:

<code language="cs">
class Counter : Component
{
  public In<StdLogic> Clk { private get; set; }
  public Out<StdLogicVector> Ctr { private get; set; }

  private SLVSignal `_`ctr;

  public Counter(int width)
  {
    `_`ctr = new SLVSignal(StdLogicVector.`_`1s(width));
  }

  private void Processing()
  {
    if (Clk.RisingEdge())
    {
      Ctr.Next = ctr.Cur;
      `_`ctr.Next = `_`ctr.Cur + "1";
    }
  }

  protected override void Initialize()
  {
    // Triggered process is registered here
    AddProcess(Processing, Clk);
  }
}
</code>

=== Example: Counter with threaded process ===

The following example replaces the triggered process by a threaded one.

<code language="cs">
class Counter : Component
{
  public In<StdLogic> Clk { private get; set; }
  public Out<StdLogicVector> Ctr { private get; set; }

  private SLVSignal `_`ctr;

  public Counter(int width)
  {
    `_`ctr = new SLVSignal(StdLogicVector.`_`1s(width));
  }

  private void Processing()
  {
    while (true)
    {
      DesignContext.Wait(Clk);
      if (Clk.RisingEdge())
      {
        Ctr.Next = ctr.Cur;
        `_`ctr.Next = `_`ctr.Cur + "1";
      }
    }
  }

  protected override void Initialize()
  {
    // Threaded process is registered here
    AddThread(Processing);
  }
}
</code>

=== Example: Counter with clocked thread ===

And a third example incorporating a clocked thread.

<code language="cs">
class Counter : Component
{
  public In<StdLogic> Clk { private get; set; }
  public Out<StdLogicVector> Ctr { private get; set; }

  private SLVSignal `_`ctr;

  public Counter(int width)
  {
    `_`ctr = new SLVSignal(StdLogicVector.`_`1s(width));
  }

  private void Processing()
  {
    while (true)
    {
      DesignContext.Wait();
      Ctr.Next = ctr.Cur;
      `_`ctr.Next = `_`ctr.Cur + "1";
    }
  }

  protected override void Initialize()
  {
    // Clocked thread is registered here
    AddClockedThread(Processing, Clk.RisingEdge, Clk);
  }
}
</code>