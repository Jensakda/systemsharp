#summary System#'s key concepts
#labels Phase-Design

= Introduction =

System# is a _system-level design language_ (SLDL). It's intent is to support the description of real-time embedded systems at different levels of abstraction. Precisely, System# is not a language on its own. Neither is it a new programming language, nor does it modify the syntax of any existing language. From a technological point of view, it's just a .NET library which provides the building blocks needed to construct, simulate and translate system models.

So why do we call it a language then? That's because System# comes with a bunch of design rules and coding guidelines. You're _not_ completely free in how you code your design. Just that your code is compilable and even runs without throwing an exception does not mean it's a valid System# design. If you want to create re-usable designs and if you want the System# framework to analyze and translate your design, you'd better adhere to the rules. That's why we call System# a _domain-specific embedded language_ (DSEL). Theoretically, you can use any .NET-enabled language to implement your design. However, we recommend C# as it provides just the right syntactic sugar needed you describe System# designs efficiently.

= Why yet-another-SLDL? =

You're probably familiar with other SLDLs, such as SystemVerilog and SystemC. These widespread and matured languages assemble are large community, are supported by many EDA tools and proved their practicability in countless academic and industrial applications. So why System#? To come to the point:
  * .NET is a powerful framework whose capabilities go far beyond the built-in features of C/C++ and its standard libraries. Why not make them available to system and hardware developers?
  * Did you ever try to develop some automated code analysis for SystemC? Be it `SomeInterfaceSynthesis`, `MyCoolNewDocumentationGenerator` or `MyOwnHighlevelSynthesisAlgorithm`, you'll soon find that things get ugly. You need to setup a C++ parser and then make it understand the SystemC-specific parts. Strictly speaking, a SystemC model does not exist until it is _elaborated_. So you need to execute the elaboration part of the SystemC design, inspect its program space and combine this information with the abstract syntax tree generated by your parser. Intricate! That's why SystemC synthesis is supported by only few commercially-available wickedly expensive tools. The .NET framework, however, simplifies things a lot: It provides a powerful reflection API and requires application binaries to be encoded in a standardized platform-independent intermediate representation: the Common Intermediate Language (CIL). CIL was indeed designed for manageable program analysis: Any CIL just-in-time compiler applies inference techniques in order to deliver optimal target code. With the help of reflection and CIL analysis, System# is able to provide a clean reflection interface for system-level designs. This interface is used for model-to-model transformations and implementation code synthesis. A major goal of System# is to provide researchers an open and flexible integration platform to prototype behavioral synthesis algorithms, model-to-model transformations, code generators and applications we don't even think of.

= Details =

Add your content here.  Format your content with:
  * Text in *bold* or _italic_
  * Headings, paragraphs, and lists
  * Automatic links to other wiki pages